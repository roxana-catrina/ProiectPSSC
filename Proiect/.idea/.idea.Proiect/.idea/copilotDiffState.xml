<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Proiect/Application/Inventory/Commands/InventoryCommands.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Proiect/Application/Inventory/Commands/InventoryCommands.cs" />
              <option name="originalContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - APPLICATION LAYER (COMMANDS)&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Comenzi pentru gestionarea inventarului&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;namespace InventoryManagement.Application.Inventory.Commands;&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: ReserveStock&#10;/// Declanșează: StockReserved event&#10;/// Validări:&#10;/// - Quantity &gt; 0&#10;/// - SKU există&#10;/// - ReservationId nu există deja (idempotency)&#10;/// - Cantitate disponibilă &gt;= cantitate cerută&#10;/// &lt;/summary&gt;&#10;public record ReserveStock(&#10;    string Sku,&#10;    Guid ReservationId,&#10;    int Quantity,&#10;    string Reason,&#10;    DateTime? ExpiresAt = null&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: ReleaseStock&#10;/// Declanșează: StockReleased event&#10;/// Validări:&#10;/// - Quantity &gt; 0&#10;/// - ReservationId există&#10;/// - Cantitatea eliberată &lt;= cantitatea rezervată&#10;/// &lt;/summary&gt;&#10;public record ReleaseStock(&#10;    string Sku,&#10;    Guid ReservationId,&#10;    int Quantity,&#10;    string Reason&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: CommitReservation&#10;/// Declanșează: StockCommitted event&#10;/// Validări:&#10;/// - ReservationId există&#10;/// - TotalOnHand &gt;= cantitatea rezervată&#10;/// &lt;/summary&gt;&#10;public record CommitReservation(&#10;    string Sku,&#10;    Guid ReservationId,&#10;    string Reason&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: IncreaseStock&#10;/// Declanșează: StockIncreased event&#10;/// Validări:&#10;/// - Quantity &gt; 0&#10;/// &lt;/summary&gt;&#10;public record IncreaseStock(&#10;    string Sku,&#10;    int Quantity,&#10;    string Reason&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: DecreaseStock&#10;/// Declanșează: StockDecreased event&#10;/// Validări:&#10;/// - Quantity &gt; 0&#10;/// - TotalOnHand &gt;= Quantity&#10;/// &lt;/summary&gt;&#10;public record DecreaseStock(&#10;    string Sku,&#10;    int Quantity,&#10;    string Reason&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: CreateInventoryItem&#10;/// Inițializează un nou produs în inventar&#10;/// &lt;/summary&gt;&#10;public record CreateInventoryItem(&#10;    string Sku,&#10;    int InitialStock,&#10;    int MinimumStockLevel,&#10;    int ReorderPoint&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: ExpireReservations&#10;/// Eliberează automat rezervările expirate&#10;/// &lt;/summary&gt;&#10;public record ExpireReservations(string Sku);&#10;" />
              <option name="updatedContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - APPLICATION LAYER (COMMANDS)&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Comenzi pentru gestionarea inventarului&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;namespace Proiect.Application.Inventory.Commands;&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: ReserveStock&#10;/// Declanșează: StockReserved event&#10;/// Validări:&#10;/// - Quantity &gt; 0&#10;/// - SKU există&#10;/// - ReservationId nu există deja (idempotency)&#10;/// - Cantitate disponibilă &gt;= cantitate cerută&#10;/// &lt;/summary&gt;&#10;public record ReserveStock(&#10;    string Sku,&#10;    Guid ReservationId,&#10;    int Quantity,&#10;    string Reason,&#10;    DateTime? ExpiresAt = null&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: ReleaseStock&#10;/// Declanșează: StockReleased event&#10;/// Validări:&#10;/// - Quantity &gt; 0&#10;/// - ReservationId există&#10;/// - Cantitatea eliberată &lt;= cantitatea rezervată&#10;/// &lt;/summary&gt;&#10;public record ReleaseStock(&#10;    string Sku,&#10;    Guid ReservationId,&#10;    int Quantity,&#10;    string Reason&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: CommitReservation&#10;/// Declanșează: StockCommitted event&#10;/// Validări:&#10;/// - ReservationId există&#10;/// - TotalOnHand &gt;= cantitatea rezervată&#10;/// &lt;/summary&gt;&#10;public record CommitReservation(&#10;    string Sku,&#10;    Guid ReservationId,&#10;    string Reason&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: IncreaseStock&#10;/// Declanșează: StockIncreased event&#10;/// Validări:&#10;/// - Quantity &gt; 0&#10;/// &lt;/summary&gt;&#10;public record IncreaseStock(&#10;    string Sku,&#10;    int Quantity,&#10;    string Reason&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: DecreaseStock&#10;/// Declanșează: StockDecreased event&#10;/// Validări:&#10;/// - Quantity &gt; 0&#10;/// - TotalOnHand &gt;= Quantity&#10;/// &lt;/summary&gt;&#10;public record DecreaseStock(&#10;    string Sku,&#10;    int Quantity,&#10;    string Reason&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: CreateInventoryItem&#10;/// Inițializează un nou produs în inventar&#10;/// &lt;/summary&gt;&#10;public record CreateInventoryItem(&#10;    string Sku,&#10;    int InitialStock,&#10;    int MinimumStockLevel,&#10;    int ReorderPoint&#10;);&#10;&#10;/// &lt;summary&gt;&#10;/// COMANDĂ: ExpireReservations&#10;/// Eliberează automat rezervările expirate&#10;/// &lt;/summary&gt;&#10;public record ExpireReservations(string Sku);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Proiect/Application/Inventory/Handlers/InventoryCommandHandlers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Proiect/Application/Inventory/Handlers/InventoryCommandHandlers.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - APPLICATION LAYER (HANDLERS)&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Command Handlers pentru gestionarea inventarului&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;using Proiect.Application.Inventory.Commands;&#10;using Proiect.Domain.Inventory;&#10;using Proiect.Infrastructure.Persistence;&#10;&#10;namespace Proiect.Application.Inventory.Handlers;&#10;&#10;/// &lt;summary&gt;&#10;/// Handler pentru comenzile de inventar&#10;/// Orchestrează operațiile între comenzi, agregat și repository&#10;/// &lt;/summary&gt;&#10;public class InventoryCommandHandlers&#10;{&#10;    private readonly IInventoryRepository _repository;&#10;    &#10;    public InventoryCommandHandlers(IInventoryRepository repository)&#10;    {&#10;        _repository = repository ?? throw new ArgumentNullException(nameof(repository));&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // HANDLER: CreateInventoryItem&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public async Task&lt;InventoryItem&gt; HandleCreateInventoryItem(CreateInventoryItem command)&#10;    {&#10;        // Verifică dacă SKU-ul există deja&#10;        var existing = await _repository.GetBySkuAsync(command.Sku);&#10;        if (existing != null)&#10;        {&#10;            throw new InvalidOperationException($&quot;Inventory item with SKU {command.Sku} already exists&quot;);&#10;        }&#10;        &#10;        // Creează agregatul&#10;        var inventoryItem = new InventoryItem(&#10;            command.Sku,&#10;            command.InitialStock,&#10;            command.MinimumStockLevel,&#10;            command.ReorderPoint&#10;        );&#10;        &#10;        // Persistă&#10;        await _repository.SaveAsync(inventoryItem);&#10;        &#10;        return inventoryItem;&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // HANDLER: ReserveStock&#10;    // Declanșează: StockReserved event&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public async Task HandleReserveStock(ReserveStock command)&#10;    {&#10;        // Încarcă agregatul&#10;        var inventoryItem = await _repository.GetBySkuAsync(command.Sku);&#10;        &#10;        if (inventoryItem == null)&#10;        {&#10;            throw new InvalidOperationException($&quot;Inventory item with SKU {command.Sku} not found&quot;);&#10;        }&#10;        &#10;        // Execută comanda pe agregat (validări + business logic)&#10;        inventoryItem.Reserve(&#10;            command.ReservationId,&#10;            command.Quantity,&#10;            command.Reason,&#10;            command.ExpiresAt&#10;        );&#10;        &#10;        // Persistă schimbările&#10;        await _repository.SaveAsync(inventoryItem);&#10;        &#10;        // Publică evenimentele (aici ar trebui un event bus)&#10;        // await _eventPublisher.PublishAsync(inventoryItem.UncommittedEvents);&#10;        &#10;        inventoryItem.ClearUncommittedEvents();&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // HANDLER: ReleaseStock&#10;    // Declanșează: StockReleased event&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public async Task HandleReleaseStock(ReleaseStock command)&#10;    {&#10;        var inventoryItem = await _repository.GetBySkuAsync(command.Sku);&#10;        &#10;        if (inventoryItem == null)&#10;        {&#10;            throw new InvalidOperationException($&quot;Inventory item with SKU {command.Sku} not found&quot;);&#10;        }&#10;        &#10;        // Execută comanda&#10;        inventoryItem.Release(&#10;            command.ReservationId,&#10;            command.Quantity,&#10;            command.Reason&#10;        );&#10;        &#10;        // Persistă&#10;        await _repository.SaveAsync(inventoryItem);&#10;        &#10;        // Publică evenimente&#10;        // await _eventPublisher.PublishAsync(inventoryItem.UncommittedEvents);&#10;        &#10;        inventoryItem.ClearUncommittedEvents();&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // HANDLER: CommitReservation&#10;    // Declanșează: StockCommitted event&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public async Task HandleCommitReservation(CommitReservation command)&#10;    {&#10;        var inventoryItem = await _repository.GetBySkuAsync(command.Sku);&#10;        &#10;        if (inventoryItem == null)&#10;        {&#10;            throw new InvalidOperationException($&quot;Inventory item with SKU {command.Sku} not found&quot;);&#10;        }&#10;        &#10;        inventoryItem.CommitReservation(command.ReservationId, command.Reason);&#10;        &#10;        await _repository.SaveAsync(inventoryItem);&#10;        &#10;        inventoryItem.ClearUncommittedEvents();&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // HANDLER: IncreaseStock&#10;    // Declanșează: StockIncreased event&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public async Task HandleIncreaseStock(IncreaseStock command)&#10;    {&#10;        var inventoryItem = await _repository.GetBySkuAsync(command.Sku);&#10;        &#10;        if (inventoryItem == null)&#10;        {&#10;            throw new InvalidOperationException($&quot;Inventory item with SKU {command.Sku} not found&quot;);&#10;        }&#10;        &#10;        inventoryItem.IncreaseStock(command.Quantity, command.Reason);&#10;        &#10;        await _repository.SaveAsync(inventoryItem);&#10;        &#10;        inventoryItem.ClearUncommittedEvents();&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // HANDLER: DecreaseStock&#10;    // Declanșează: StockDecreased event&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public async Task HandleDecreaseStock(DecreaseStock command)&#10;    {&#10;        var inventoryItem = await _repository.GetBySkuAsync(command.Sku);&#10;        &#10;        if (inventoryItem == null)&#10;        {&#10;            throw new InvalidOperationException($&quot;Inventory item with SKU {command.Sku} not found&quot;);&#10;        }&#10;        &#10;        inventoryItem.DecreaseStock(command.Quantity, command.Reason);&#10;        &#10;        await _repository.SaveAsync(inventoryItem);&#10;        &#10;        inventoryItem.ClearUncommittedEvents();&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // HANDLER: ExpireReservations&#10;    // Eliberează automat rezervările expirate&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public async Task HandleExpireReservations(ExpireReservations command)&#10;    {&#10;        var inventoryItem = await _repository.GetBySkuAsync(command.Sku);&#10;        &#10;        if (inventoryItem == null)&#10;        {&#10;            return; // Nu există item, nimic de făcut&#10;        }&#10;        &#10;        inventoryItem.ExpireReservations();&#10;        &#10;        if (inventoryItem.UncommittedEvents.Any())&#10;        {&#10;            await _repository.SaveAsync(inventoryItem);&#10;            inventoryItem.ClearUncommittedEvents();&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // HELPER: ExpireAllReservations&#10;    // Job periodic care expiră toate rezervările din sistem&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public async Task ExpireAllReservationsAsync()&#10;    {&#10;        var allItems = await _repository.GetAllAsync();&#10;        &#10;        foreach (var item in allItems)&#10;        {&#10;            item.ExpireReservations();&#10;            &#10;            if (item.UncommittedEvents.Any())&#10;            {&#10;                await _repository.SaveAsync(item);&#10;                item.ClearUncommittedEvents();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Proiect/Controllers/InventoryController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Proiect/Controllers/InventoryController.cs" />
              <option name="originalContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - API LAYER&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Controller pentru expunerea operațiilor de inventar&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;using Microsoft.AspNetCore.Mvc;&#10;using InventoryManagement.Application.Inventory.Commands;&#10;using InventoryManagement.Application.Inventory.Handlers;&#10;using InventoryManagement.Infrastructure.Persistence;&#10;&#10;namespace Proiect.Controllers;&#10;&#10;[ApiController]&#10;[Route(&quot;api/[controller]&quot;)]&#10;public class InventoryController : ControllerBase&#10;{&#10;    private readonly InventoryCommandHandlers _commandHandlers;&#10;    private readonly IInventoryRepository _repository;&#10;    &#10;    public InventoryController(&#10;        InventoryCommandHandlers commandHandlers,&#10;        IInventoryRepository repository)&#10;    {&#10;        _commandHandlers = commandHandlers;&#10;        _repository = repository;&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory&#10;    // Creează un nou item de inventar&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost]&#10;    public async Task&lt;IActionResult&gt; CreateInventoryItem([FromBody] CreateInventoryItem command)&#10;    {&#10;        try&#10;        {&#10;            var item = await _commandHandlers.HandleCreateInventoryItem(command);&#10;            return CreatedAtAction(nameof(GetInventoryItem), new { sku = item.Sku }, new&#10;            {&#10;                sku = item.Sku,&#10;                totalOnHand = item.TotalOnHand,&#10;                available = item.Available,&#10;                minimumStockLevel = item.MinimumStockLevel,&#10;                reorderPoint = item.ReorderPoint&#10;            });&#10;        }&#10;        catch (InvalidOperationException ex)&#10;        {&#10;            return Conflict(new { error = ex.Message });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // GET: api/inventory/{sku}&#10;    // Obține detalii despre un item de inventar&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpGet(&quot;{sku}&quot;)]&#10;    public async Task&lt;IActionResult&gt; GetInventoryItem(string sku)&#10;    {&#10;        var item = await _repository.GetBySkuAsync(sku);&#10;        &#10;        if (item == null)&#10;            return NotFound(new { error = $&quot;Inventory item {sku} not found&quot; });&#10;        &#10;        return Ok(new&#10;        {&#10;            sku = item.Sku,&#10;            totalOnHand = item.TotalOnHand,&#10;            available = item.Available,&#10;            minimumStockLevel = item.MinimumStockLevel,&#10;            reorderPoint = item.ReorderPoint,&#10;            isLowStock = item.IsLowStock,&#10;            needsReorder = item.NeedsReorder,&#10;            reservations = item.Reservations.Select(r =&gt; new&#10;            {&#10;                reservationId = r.ReservationId,&#10;                quantity = r.Quantity,&#10;                reason = r.Reason,&#10;                reservedAt = r.ReservedAt,&#10;                expiresAt = r.ExpiresAt,&#10;                isExpired = r.IsExpired&#10;            })&#10;        });&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // GET: api/inventory&#10;    // Obține toate itemele de inventar&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpGet]&#10;    public async Task&lt;IActionResult&gt; GetAllInventoryItems()&#10;    {&#10;        var items = await _repository.GetAllAsync();&#10;        &#10;        return Ok(items.Select(item =&gt; new&#10;        {&#10;            sku = item.Sku,&#10;            totalOnHand = item.TotalOnHand,&#10;            available = item.Available,&#10;            minimumStockLevel = item.MinimumStockLevel,&#10;            reorderPoint = item.ReorderPoint,&#10;            isLowStock = item.IsLowStock,&#10;            needsReorder = item.NeedsReorder,&#10;            reservationsCount = item.Reservations.Count&#10;        }));&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/reserve&#10;    // COMANDĂ: ReserveStock → EVENIMENT: StockReserved&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/reserve&quot;)]&#10;    public async Task&lt;IActionResult&gt; ReserveStock(string sku, [FromBody] ReserveStockRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new ReserveStock(&#10;                sku,&#10;                request.ReservationId ?? Guid.NewGuid(),&#10;                request.Quantity,&#10;                request.Reason ?? &quot;Order placed&quot;,&#10;                request.ExpiresAt&#10;            );&#10;            &#10;            await _commandHandlers.HandleReserveStock(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Stock reserved successfully&quot;,&#10;                sku = sku,&#10;                reservationId = command.ReservationId,&#10;                quantity = command.Quantity&#10;            });&#10;        }&#10;        catch (InvalidOperationException ex)&#10;        {&#10;            return NotFound(new { error = ex.Message });&#10;        }&#10;        catch (Domain.Inventory.InsufficientStockException ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message, type = &quot;InsufficientStock&quot; });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/release&#10;    // COMANDĂ: ReleaseStock → EVENIMENT: StockReleased&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/release&quot;)]&#10;    public async Task&lt;IActionResult&gt; ReleaseStock(string sku, [FromBody] ReleaseStockRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new ReleaseStock(&#10;                sku,&#10;                request.ReservationId,&#10;                request.Quantity,&#10;                request.Reason ?? &quot;Order cancelled&quot;&#10;            );&#10;            &#10;            await _commandHandlers.HandleReleaseStock(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Stock released successfully&quot;,&#10;                sku = sku,&#10;                reservationId = command.ReservationId,&#10;                quantity = command.Quantity&#10;            });&#10;        }&#10;        catch (InvalidOperationException ex)&#10;        {&#10;            return NotFound(new { error = ex.Message });&#10;        }&#10;        catch (Domain.Inventory.ReservationNotFoundException ex)&#10;        {&#10;            return NotFound(new { error = ex.Message, type = &quot;ReservationNotFound&quot; });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/commit&#10;    // COMANDĂ: CommitReservation → EVENIMENT: StockCommitted&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/commit&quot;)]&#10;    public async Task&lt;IActionResult&gt; CommitReservation(string sku, [FromBody] CommitReservationRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new CommitReservation(&#10;                sku,&#10;                request.ReservationId,&#10;                request.Reason ?? &quot;Order shipped&quot;&#10;            );&#10;            &#10;            await _commandHandlers.HandleCommitReservation(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Reservation committed successfully&quot;,&#10;                sku = sku,&#10;                reservationId = command.ReservationId&#10;            });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/increase&#10;    // COMANDĂ: IncreaseStock → EVENIMENT: StockIncreased&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/increase&quot;)]&#10;    public async Task&lt;IActionResult&gt; IncreaseStock(string sku, [FromBody] StockAdjustmentRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new IncreaseStock(sku, request.Quantity, request.Reason ?? &quot;Stock received&quot;);&#10;            &#10;            await _commandHandlers.HandleIncreaseStock(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Stock increased successfully&quot;,&#10;                sku = sku,&#10;                quantity = command.Quantity&#10;            });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/decrease&#10;    // COMANDĂ: DecreaseStock → EVENIMENT: StockDecreased&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/decrease&quot;)]&#10;    public async Task&lt;IActionResult&gt; DecreaseStock(string sku, [FromBody] StockAdjustmentRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new DecreaseStock(sku, request.Quantity, request.Reason ?? &quot;Stock damaged&quot;);&#10;            &#10;            await _commandHandlers.HandleDecreaseStock(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Stock decreased successfully&quot;,&#10;                sku = sku,&#10;                quantity = command.Quantity&#10;            });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/expire-reservations&#10;    // Expiră manual rezervările pentru un SKU&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/expire-reservations&quot;)]&#10;    public async Task&lt;IActionResult&gt; ExpireReservations(string sku)&#10;    {&#10;        try&#10;        {&#10;            var command = new ExpireReservations(sku);&#10;            await _commandHandlers.HandleExpireReservations(command);&#10;            &#10;            return Ok(new { message = &quot;Expired reservations released&quot;, sku = sku });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;}&#10;&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// REQUEST DTOs&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;public record ReserveStockRequest(&#10;    int Quantity,&#10;    Guid? ReservationId = null,&#10;    string? Reason = null,&#10;    DateTime? ExpiresAt = null&#10;);&#10;&#10;public record ReleaseStockRequest(&#10;    Guid ReservationId,&#10;    int Quantity,&#10;    string? Reason = null&#10;);&#10;&#10;public record CommitReservationRequest(&#10;    Guid ReservationId,&#10;    string? Reason = null&#10;);&#10;&#10;public record StockAdjustmentRequest(&#10;    int Quantity,&#10;    string? Reason = null&#10;);&#10;" />
              <option name="updatedContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - API LAYER&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Controller pentru expunerea operațiilor de inventar&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;using Microsoft.AspNetCore.Mvc;&#10;using Proiect.Application.Inventory.Commands;&#10;using Proiect.Application.Inventory.Handlers;&#10;using Proiect.Infrastructure.Persistence;&#10;using Proiect.Domain.Inventory;&#10;&#10;namespace Proiect.Controllers;&#10;&#10;[ApiController]&#10;[Route(&quot;api/[controller]&quot;)]&#10;public class InventoryController : ControllerBase&#10;{&#10;    private readonly InventoryCommandHandlers _commandHandlers;&#10;    private readonly IInventoryRepository _repository;&#10;    &#10;    public InventoryController(&#10;        InventoryCommandHandlers commandHandlers,&#10;        IInventoryRepository repository)&#10;    {&#10;        _commandHandlers = commandHandlers;&#10;        _repository = repository;&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory&#10;    // Creează un nou item de inventar&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost]&#10;    public async Task&lt;IActionResult&gt; CreateInventoryItem([FromBody] CreateInventoryItem command)&#10;    {&#10;        try&#10;        {&#10;            var item = await _commandHandlers.HandleCreateInventoryItem(command);&#10;            return CreatedAtAction(nameof(GetInventoryItem), new { sku = item.Sku }, new&#10;            {&#10;                sku = item.Sku,&#10;                totalOnHand = item.TotalOnHand,&#10;                available = item.Available,&#10;                minimumStockLevel = item.MinimumStockLevel,&#10;                reorderPoint = item.ReorderPoint&#10;            });&#10;        }&#10;        catch (InvalidOperationException ex)&#10;        {&#10;            return Conflict(new { error = ex.Message });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // GET: api/inventory/{sku}&#10;    // Obține detalii despre un item de inventar&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpGet(&quot;{sku}&quot;)]&#10;    public async Task&lt;IActionResult&gt; GetInventoryItem(string sku)&#10;    {&#10;        var item = await _repository.GetBySkuAsync(sku);&#10;        &#10;        if (item == null)&#10;            return NotFound(new { error = $&quot;Inventory item {sku} not found&quot; });&#10;        &#10;        return Ok(new&#10;        {&#10;            sku = item.Sku,&#10;            totalOnHand = item.TotalOnHand,&#10;            available = item.Available,&#10;            minimumStockLevel = item.MinimumStockLevel,&#10;            reorderPoint = item.ReorderPoint,&#10;            isLowStock = item.IsLowStock,&#10;            needsReorder = item.NeedsReorder,&#10;            reservations = item.Reservations.Select(r =&gt; new&#10;            {&#10;                reservationId = r.ReservationId,&#10;                quantity = r.Quantity,&#10;                reason = r.Reason,&#10;                reservedAt = r.ReservedAt,&#10;                expiresAt = r.ExpiresAt,&#10;                isExpired = r.IsExpired&#10;            })&#10;        });&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // GET: api/inventory&#10;    // Obține toate itemele de inventar&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpGet]&#10;    public async Task&lt;IActionResult&gt; GetAllInventoryItems()&#10;    {&#10;        var items = await _repository.GetAllAsync();&#10;        &#10;        return Ok(items.Select(item =&gt; new&#10;        {&#10;            sku = item.Sku,&#10;            totalOnHand = item.TotalOnHand,&#10;            available = item.Available,&#10;            minimumStockLevel = item.MinimumStockLevel,&#10;            reorderPoint = item.ReorderPoint,&#10;            isLowStock = item.IsLowStock,&#10;            needsReorder = item.NeedsReorder,&#10;            reservationsCount = item.Reservations.Count&#10;        }));&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/reserve&#10;    // COMANDĂ: ReserveStock → EVENIMENT: StockReserved&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/reserve&quot;)]&#10;    public async Task&lt;IActionResult&gt; ReserveStock(string sku, [FromBody] ReserveStockRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new ReserveStock(&#10;                sku,&#10;                request.ReservationId ?? Guid.NewGuid(),&#10;                request.Quantity,&#10;                request.Reason ?? &quot;Order placed&quot;,&#10;                request.ExpiresAt&#10;            );&#10;            &#10;            await _commandHandlers.HandleReserveStock(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Stock reserved successfully&quot;,&#10;                sku,&#10;                reservationId = command.ReservationId,&#10;                quantity = command.Quantity&#10;            });&#10;        }&#10;        catch (InvalidOperationException ex)&#10;        {&#10;            return NotFound(new { error = ex.Message });&#10;        }&#10;        catch (InsufficientStockException ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message, type = &quot;InsufficientStock&quot; });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/release&#10;    // COMANDĂ: ReleaseStock → EVENIMENT: StockReleased&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/release&quot;)]&#10;    public async Task&lt;IActionResult&gt; ReleaseStock(string sku, [FromBody] ReleaseStockRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new ReleaseStock(&#10;                sku,&#10;                request.ReservationId,&#10;                request.Quantity,&#10;                request.Reason ?? &quot;Order cancelled&quot;&#10;            );&#10;            &#10;            await _commandHandlers.HandleReleaseStock(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Stock released successfully&quot;,&#10;                sku,&#10;                reservationId = command.ReservationId,&#10;                quantity = command.Quantity&#10;            });&#10;        }&#10;        catch (InvalidOperationException ex)&#10;        {&#10;            return NotFound(new { error = ex.Message });&#10;        }&#10;        catch (ReservationNotFoundException ex)&#10;        {&#10;            return NotFound(new { error = ex.Message, type = &quot;ReservationNotFound&quot; });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/commit&#10;    // COMANDĂ: CommitReservation → EVENIMENT: StockCommitted&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/commit&quot;)]&#10;    public async Task&lt;IActionResult&gt; CommitReservation(string sku, [FromBody] CommitReservationRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new CommitReservation(&#10;                sku,&#10;                request.ReservationId,&#10;                request.Reason ?? &quot;Order shipped&quot;&#10;            );&#10;            &#10;            await _commandHandlers.HandleCommitReservation(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Reservation committed successfully&quot;,&#10;                sku,&#10;                reservationId = command.ReservationId&#10;            });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/increase&#10;    // COMANDĂ: IncreaseStock → EVENIMENT: StockIncreased&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/increase&quot;)]&#10;    public async Task&lt;IActionResult&gt; IncreaseStock(string sku, [FromBody] StockAdjustmentRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new IncreaseStock(sku, request.Quantity, request.Reason ?? &quot;Stock received&quot;);&#10;            &#10;            await _commandHandlers.HandleIncreaseStock(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Stock increased successfully&quot;,&#10;                sku,&#10;                quantity = command.Quantity&#10;            });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/decrease&#10;    // COMANDĂ: DecreaseStock → EVENIMENT: StockDecreased&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/decrease&quot;)]&#10;    public async Task&lt;IActionResult&gt; DecreaseStock(string sku, [FromBody] StockAdjustmentRequest request)&#10;    {&#10;        try&#10;        {&#10;            var command = new DecreaseStock(sku, request.Quantity, request.Reason ?? &quot;Stock damaged&quot;);&#10;            &#10;            await _commandHandlers.HandleDecreaseStock(command);&#10;            &#10;            return Ok(new&#10;            {&#10;                message = &quot;Stock decreased successfully&quot;,&#10;                sku,&#10;                quantity = command.Quantity&#10;            });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // POST: api/inventory/{sku}/expire-reservations&#10;    // Expiră manual rezervările pentru un SKU&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    [HttpPost(&quot;{sku}/expire-reservations&quot;)]&#10;    public async Task&lt;IActionResult&gt; ExpireReservations(string sku)&#10;    {&#10;        try&#10;        {&#10;            var command = new ExpireReservations(sku);&#10;            await _commandHandlers.HandleExpireReservations(command);&#10;            &#10;            return Ok(new { message = &quot;Expired reservations released&quot;, sku });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return BadRequest(new { error = ex.Message });&#10;        }&#10;    }&#10;}&#10;&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// REQUEST DTOs&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;public record ReserveStockRequest(&#10;    int Quantity,&#10;    Guid? ReservationId = null,&#10;    string? Reason = null,&#10;    DateTime? ExpiresAt = null&#10;);&#10;&#10;public record ReleaseStockRequest(&#10;    Guid ReservationId,&#10;    int Quantity,&#10;    string? Reason = null&#10;);&#10;&#10;public record CommitReservationRequest(&#10;    Guid ReservationId,&#10;    string? Reason = null&#10;);&#10;&#10;public record StockAdjustmentRequest(&#10;    int Quantity,&#10;    string? Reason = null&#10;);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Proiect/Domain/Inventory/InventoryItem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Proiect/Domain/Inventory/InventoryItem.cs" />
              <option name="originalContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - DOMAIN LAYER&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Agregat: InventoryItem - gestionează stocul și rezervările&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;using InventoryManagement.Domain.Inventory.Events;&#10;&#10;namespace InventoryManagement.Domain.Inventory;&#10;&#10;/// &lt;summary&gt;&#10;/// AGREGAT ROOT: InventoryItem&#10;/// Gestionează stocul pentru un SKU și rezervările asociate&#10;/// &#10;/// INVARIANȚI:&#10;/// 1. TotalOnHand &gt;= 0 (nu există stoc negativ)&#10;/// 2. Suma rezervărilor &lt;= TotalOnHand&#10;/// 3. Fiecare rezervare are cantitate &gt; 0&#10;/// 4. ReservationId este unic în cadrul agregatului&#10;/// 5. Cantitatea disponibilă (Available) &gt;= 0&#10;/// &lt;/summary&gt;&#10;public class InventoryItem&#10;{&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // STATE (Encapsulated)&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public string Sku { get; private set; }&#10;    public int TotalOnHand { get; private set; }&#10;    public int MinimumStockLevel { get; private set; }&#10;    public int ReorderPoint { get; private set; }&#10;    &#10;    private readonly Dictionary&lt;Guid, Reservation&gt; _reservations = new();&#10;    &#10;    // Pentru event sourcing - evenimente necomise&#10;    private readonly List&lt;object&gt; _uncommittedEvents = new();&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // COMPUTED PROPERTIES&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Cantitatea disponibilă pentru rezervări = TotalOnHand - Suma rezervărilor&#10;    /// &lt;/summary&gt;&#10;    public int Available =&gt; TotalOnHand - _reservations.Values.Sum(r =&gt; r.Quantity);&#10;    &#10;    public IReadOnlyCollection&lt;Reservation&gt; Reservations =&gt; _reservations.Values.ToList().AsReadOnly();&#10;    &#10;    public IReadOnlyList&lt;object&gt; UncommittedEvents =&gt; _uncommittedEvents.AsReadOnly();&#10;    &#10;    public bool IsLowStock =&gt; TotalOnHand &lt;= MinimumStockLevel;&#10;    &#10;    public bool NeedsReorder =&gt; TotalOnHand &lt;= ReorderPoint;&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // CONSTRUCTOR&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public InventoryItem(string sku, int initialOnHand = 0, int minimumStockLevel = 0, int reorderPoint = 0)&#10;    {&#10;        if (string.IsNullOrWhiteSpace(sku))&#10;            throw new InvalidInventoryCommandException(&quot;SKU cannot be empty&quot;);&#10;        &#10;        if (initialOnHand &lt; 0)&#10;            throw new InvalidInventoryCommandException(&quot;Initial stock cannot be negative&quot;);&#10;        &#10;        if (minimumStockLevel &lt; 0)&#10;            throw new InvalidInventoryCommandException(&quot;Minimum stock level cannot be negative&quot;);&#10;        &#10;        if (reorderPoint &lt; 0)&#10;            throw new InvalidInventoryCommandException(&quot;Reorder point cannot be negative&quot;);&#10;        &#10;        Sku = sku;&#10;        TotalOnHand = initialOnHand;&#10;        MinimumStockLevel = minimumStockLevel;&#10;        ReorderPoint = reorderPoint;&#10;        &#10;        EnsureInvariants();&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // BUSINESS OPERATIONS (Commands → Events)&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: Reserve&#10;    /// Rezervă o cantitate din stoc pentru o comandă&#10;    /// EMITE: StockReserved&#10;    /// &lt;/summary&gt;&#10;    public void Reserve(Guid reservationId, int quantity, string reason, DateTime? expiresAt = null)&#10;    {&#10;        // VALIDĂRI (Reguli de business)&#10;        if (quantity &lt;= 0)&#10;            throw new InvalidInventoryCommandException(&quot;Quantity must be greater than 0&quot;);&#10;        &#10;        if (_reservations.ContainsKey(reservationId))&#10;            throw new InvalidInventoryCommandException($&quot;Reservation {reservationId} already exists (idempotency check)&quot;);&#10;        &#10;        if (quantity &gt; Available)&#10;            throw new InsufficientStockException(&#10;                $&quot;Insufficient stock for SKU {Sku}. Available: {Available}, Requested: {quantity}&quot;);&#10;        &#10;        if (expiresAt.HasValue &amp;&amp; expiresAt.Value &lt;= DateTime.UtcNow)&#10;            throw new InvalidInventoryCommandException(&quot;Expiration date must be in the future&quot;);&#10;        &#10;        // OPERAȚIE&#10;        var reservation = new Reservation(reservationId, quantity, reason, expiresAt ?? DateTime.UtcNow.AddHours(24));&#10;        _reservations.Add(reservationId, reservation);&#10;        &#10;        // VERIFICARE INVARIANȚI&#10;        EnsureInvariants();&#10;        &#10;        // EVENIMENT&#10;        var @event = new StockReserved(&#10;            Sku,&#10;            reservationId,&#10;            quantity,&#10;            reason,&#10;            reservation.ReservedAt,&#10;            reservation.ExpiresAt);&#10;        &#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: Release&#10;    /// Eliberează o rezervare (total sau parțial)&#10;    /// EMITE: StockReleased&#10;    /// &lt;/summary&gt;&#10;    public void Release(Guid reservationId, int quantity, string reason)&#10;    {&#10;        // VALIDĂRI&#10;        if (quantity &lt;= 0)&#10;            throw new InvalidInventoryCommandException(&quot;Quantity must be greater than 0&quot;);&#10;        &#10;        if (!_reservations.TryGetValue(reservationId, out var reservation))&#10;            throw new ReservationNotFoundException($&quot;Reservation {reservationId} not found for SKU {Sku}&quot;);&#10;        &#10;        if (quantity &gt; reservation.Quantity)&#10;            throw new InvalidInventoryCommandException(&#10;                $&quot;Cannot release more than reserved. Reserved: {reservation.Quantity}, Requested: {quantity}&quot;);&#10;        &#10;        // OPERAȚIE&#10;        int releasedQuantity = quantity;&#10;        reservation.Quantity -= quantity;&#10;        &#10;        if (reservation.Quantity == 0)&#10;        {&#10;            _reservations.Remove(reservationId);&#10;        }&#10;        &#10;        // VERIFICARE INVARIANȚI&#10;        EnsureInvariants();&#10;        &#10;        // EVENIMENT&#10;        var @event = new StockReleased(&#10;            Sku,&#10;            reservationId,&#10;            releasedQuantity,&#10;            reason,&#10;            DateTime.UtcNow);&#10;        &#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: CommitReservation&#10;    /// Transformă o rezervare în consum efectiv (ex: la shipping)&#10;    /// &lt;/summary&gt;&#10;    public void CommitReservation(Guid reservationId, string reason)&#10;    {&#10;        if (!_reservations.TryGetValue(reservationId, out var reservation))&#10;            throw new ReservationNotFoundException($&quot;Reservation {reservationId} not found&quot;);&#10;        &#10;        // Scadem din stoc și eliminăm rezervarea&#10;        TotalOnHand -= reservation.Quantity;&#10;        _reservations.Remove(reservationId);&#10;        &#10;        EnsureInvariants();&#10;        &#10;        var @event = new StockCommitted(Sku, reservationId, reservation.Quantity, reason, DateTime.UtcNow);&#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: IncreaseStock&#10;    /// Adaugă stoc (ex: recepție marfă)&#10;    /// &lt;/summary&gt;&#10;    public void IncreaseStock(int quantity, string reason)&#10;    {&#10;        if (quantity &lt;= 0)&#10;            throw new InvalidInventoryCommandException(&quot;Quantity must be greater than 0&quot;);&#10;        &#10;        TotalOnHand += quantity;&#10;        &#10;        EnsureInvariants();&#10;        &#10;        var @event = new StockIncreased(Sku, quantity, reason, DateTime.UtcNow);&#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: DecreaseStock&#10;    /// Scade stoc direct (ex: deteriorare, pierdere)&#10;    /// &lt;/summary&gt;&#10;    public void DecreaseStock(int quantity, string reason)&#10;    {&#10;        if (quantity &lt;= 0)&#10;            throw new InvalidInventoryCommandException(&quot;Quantity must be greater than 0&quot;);&#10;        &#10;        if (quantity &gt; TotalOnHand)&#10;            throw new InvalidInventoryCommandException(&#10;                $&quot;Cannot decrease more than on-hand. On-hand: {TotalOnHand}, Requested: {quantity}&quot;);&#10;        &#10;        TotalOnHand -= quantity;&#10;        &#10;        EnsureInvariants();&#10;        &#10;        var @event = new StockDecreased(Sku, quantity, reason, DateTime.UtcNow);&#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: ExpireReservation&#10;    /// Eliberează automat rezervările expirate&#10;    /// &lt;/summary&gt;&#10;    public void ExpireReservations()&#10;    {&#10;        var now = DateTime.UtcNow;&#10;        var expiredReservations = _reservations.Values&#10;            .Where(r =&gt; r.ExpiresAt &lt;= now)&#10;            .ToList();&#10;        &#10;        foreach (var reservation in expiredReservations)&#10;        {&#10;            Release(reservation.ReservationId, reservation.Quantity, &quot;Reservation expired&quot;);&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // INVARIANT ENFORCEMENT&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Verifică și asigură că toți invarianții agregatului sunt respectați&#10;    /// &lt;/summary&gt;&#10;    private void EnsureInvariants()&#10;    {&#10;        // INVARIANT 1: TotalOnHand &gt;= 0&#10;        if (TotalOnHand &lt; 0)&#10;            throw new InvariantViolationException(&#10;                $&quot;INVARIANT VIOLATION: TotalOnHand cannot be negative. Current: {TotalOnHand}&quot;);&#10;        &#10;        // INVARIANT 2: Fiecare rezervare are cantitate &gt; 0&#10;        var invalidReservation = _reservations.Values.FirstOrDefault(r =&gt; r.Quantity &lt;= 0);&#10;        if (invalidReservation != null)&#10;            throw new InvariantViolationException(&#10;                $&quot;INVARIANT VIOLATION: Reservation {invalidReservation.ReservationId} has invalid quantity: {invalidReservation.Quantity}&quot;);&#10;        &#10;        // INVARIANT 3: Suma rezervărilor &lt;= TotalOnHand&#10;        var sumReserved = _reservations.Values.Sum(r =&gt; r.Quantity);&#10;        if (sumReserved &gt; TotalOnHand)&#10;            throw new InvariantViolationException(&#10;                $&quot;INVARIANT VIOLATION: Total reserved ({sumReserved}) exceeds on-hand ({TotalOnHand})&quot;);&#10;        &#10;        // INVARIANT 4: Available &gt;= 0&#10;        if (Available &lt; 0)&#10;            throw new InvariantViolationException(&#10;                $&quot;INVARIANT VIOLATION: Available quantity cannot be negative. Current: {Available}&quot;);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Șterge evenimentele necomise (după persistare)&#10;    /// &lt;/summary&gt;&#10;    public void ClearUncommittedEvents()&#10;    {&#10;        _uncommittedEvents.Clear();&#10;    }&#10;}&#10;&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// VALUE OBJECT: Reservation&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;/// &lt;summary&gt;&#10;/// Value Object pentru o rezervare de stoc&#10;/// &lt;/summary&gt;&#10;public class Reservation&#10;{&#10;    public Guid ReservationId { get; }&#10;    public int Quantity { get; set; } // Mutable pentru release parțial&#10;    public string Reason { get; }&#10;    public DateTime ReservedAt { get; }&#10;    public DateTime ExpiresAt { get; }&#10;    &#10;    public bool IsExpired =&gt; DateTime.UtcNow &gt; ExpiresAt;&#10;    &#10;    public Reservation(Guid reservationId, int quantity, string reason, DateTime expiresAt)&#10;    {&#10;        if (quantity &lt;= 0)&#10;            throw new ArgumentException(&quot;Quantity must be greater than 0&quot;, nameof(quantity));&#10;        &#10;        ReservationId = reservationId;&#10;        Quantity = quantity;&#10;        Reason = reason ?? &quot;Unknown&quot;;&#10;        ReservedAt = DateTime.UtcNow;&#10;        ExpiresAt = expiresAt;&#10;    }&#10;}&#10;&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// DOMAIN EXCEPTIONS&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;public class InvalidInventoryCommandException : Exception&#10;{&#10;    public InvalidInventoryCommandException(string message) : base(message) { }&#10;}&#10;&#10;public class InsufficientStockException : Exception&#10;{&#10;    public InsufficientStockException(string message) : base(message) { }&#10;}&#10;&#10;public class ReservationNotFoundException : Exception&#10;{&#10;    public ReservationNotFoundException(string message) : base(message) { }&#10;}&#10;&#10;public class InvariantViolationException : Exception&#10;{&#10;    public InvariantViolationException(string message) : base(message) { }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - DOMAIN LAYER&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Agregat: InventoryItem - gestionează stocul și rezervările&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;using Proiect.Domain.Inventory.Events;&#10;&#10;namespace Proiect.Domain.Inventory;&#10;&#10;/// &lt;summary&gt;&#10;/// AGREGAT ROOT: InventoryItem&#10;/// Gestionează stocul pentru un SKU și rezervările asociate&#10;/// &#10;/// INVARIANȚI:&#10;/// 1. TotalOnHand &gt;= 0 (nu există stoc negativ)&#10;/// 2. Suma rezervărilor &amp;lt;= TotalOnHand&#10;/// 3. Fiecare rezervare are cantitate &amp;gt; 0&#10;/// 4. ReservationId este unic în cadrul agregatului&#10;/// 5. Cantitatea disponibilă (Available) &gt;= 0&#10;/// &lt;/summary&gt;&#10;public class InventoryItem&#10;{&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // STATE (Encapsulated)&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public string Sku { get; private set; }&#10;    public int TotalOnHand { get; private set; }&#10;    public int MinimumStockLevel { get; private set; }&#10;    public int ReorderPoint { get; private set; }&#10;    &#10;    private readonly Dictionary&lt;Guid, Reservation&gt; _reservations = new();&#10;    &#10;    // Pentru event sourcing - evenimente necomise&#10;    private readonly List&lt;object&gt; _uncommittedEvents = new();&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // COMPUTED PROPERTIES&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Cantitatea disponibilă pentru rezervări = TotalOnHand - Suma rezervărilor&#10;    /// &lt;/summary&gt;&#10;    public int Available =&gt; TotalOnHand - _reservations.Values.Sum(r =&gt; r.Quantity);&#10;    &#10;    public IReadOnlyCollection&lt;Reservation&gt; Reservations =&gt; _reservations.Values.ToList().AsReadOnly();&#10;    &#10;    public IReadOnlyList&lt;object&gt; UncommittedEvents =&gt; _uncommittedEvents.AsReadOnly();&#10;    &#10;    public bool IsLowStock =&gt; TotalOnHand &lt;= MinimumStockLevel;&#10;    &#10;    public bool NeedsReorder =&gt; TotalOnHand &lt;= ReorderPoint;&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // CONSTRUCTOR&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    public InventoryItem(string sku, int initialOnHand = 0, int minimumStockLevel = 0, int reorderPoint = 0)&#10;    {&#10;        if (string.IsNullOrWhiteSpace(sku))&#10;            throw new InvalidInventoryCommandException(&quot;SKU cannot be empty&quot;);&#10;        &#10;        if (initialOnHand &lt; 0)&#10;            throw new InvalidInventoryCommandException(&quot;Initial stock cannot be negative&quot;);&#10;        &#10;        if (minimumStockLevel &lt; 0)&#10;            throw new InvalidInventoryCommandException(&quot;Minimum stock level cannot be negative&quot;);&#10;        &#10;        if (reorderPoint &lt; 0)&#10;            throw new InvalidInventoryCommandException(&quot;Reorder point cannot be negative&quot;);&#10;        &#10;        Sku = sku;&#10;        TotalOnHand = initialOnHand;&#10;        MinimumStockLevel = minimumStockLevel;&#10;        ReorderPoint = reorderPoint;&#10;        &#10;        EnsureInvariants();&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // BUSINESS OPERATIONS (Commands → Events)&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: Reserve&#10;    /// Rezervă o cantitate din stoc pentru o comandă&#10;    /// EMITE: StockReserved&#10;    /// &lt;/summary&gt;&#10;    public void Reserve(Guid reservationId, int quantity, string reason, DateTime? expiresAt = null)&#10;    {&#10;        // VALIDĂRI (Reguli de business)&#10;        if (quantity &lt;= 0)&#10;            throw new InvalidInventoryCommandException(&quot;Quantity must be greater than 0&quot;);&#10;        &#10;        if (_reservations.ContainsKey(reservationId))&#10;            throw new InvalidInventoryCommandException($&quot;Reservation {reservationId} already exists (idempotency check)&quot;);&#10;        &#10;        if (quantity &gt; Available)&#10;            throw new InsufficientStockException(&#10;                $&quot;Insufficient stock for SKU {Sku}. Available: {Available}, Requested: {quantity}&quot;);&#10;        &#10;        if (expiresAt.HasValue &amp;&amp; expiresAt.Value &lt;= DateTime.UtcNow)&#10;            throw new InvalidInventoryCommandException(&quot;Expiration date must be in the future&quot;);&#10;        &#10;        // OPERAȚIE&#10;        var reservation = new Reservation(reservationId, quantity, reason, expiresAt ?? DateTime.UtcNow.AddHours(24));&#10;        _reservations.Add(reservationId, reservation);&#10;        &#10;        // VERIFICARE INVARIANȚI&#10;        EnsureInvariants();&#10;        &#10;        // EVENIMENT&#10;        var @event = new StockReserved(&#10;            Sku,&#10;            reservationId,&#10;            quantity,&#10;            reason,&#10;            reservation.ReservedAt,&#10;            reservation.ExpiresAt);&#10;        &#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: Release&#10;    /// Eliberează o rezervare (total sau parțial)&#10;    /// EMITE: StockReleased&#10;    /// &lt;/summary&gt;&#10;    public void Release(Guid reservationId, int quantity, string reason)&#10;    {&#10;        // VALIDĂRI&#10;        if (quantity &lt;= 0)&#10;            throw new InvalidInventoryCommandException(&quot;Quantity must be greater than 0&quot;);&#10;        &#10;        if (!_reservations.TryGetValue(reservationId, out var reservation))&#10;            throw new ReservationNotFoundException($&quot;Reservation {reservationId} not found for SKU {Sku}&quot;);&#10;        &#10;        if (quantity &gt; reservation.Quantity)&#10;            throw new InvalidInventoryCommandException(&#10;                $&quot;Cannot release more than reserved. Reserved: {reservation.Quantity}, Requested: {quantity}&quot;);&#10;        &#10;        // OPERAȚIE&#10;        int releasedQuantity = quantity;&#10;        reservation.Quantity -= quantity;&#10;        &#10;        if (reservation.Quantity == 0)&#10;        {&#10;            _reservations.Remove(reservationId);&#10;        }&#10;        &#10;        // VERIFICARE INVARIANȚI&#10;        EnsureInvariants();&#10;        &#10;        // EVENIMENT&#10;        var @event = new StockReleased(&#10;            Sku,&#10;            reservationId,&#10;            releasedQuantity,&#10;            reason,&#10;            DateTime.UtcNow);&#10;        &#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: CommitReservation&#10;    /// Transformă o rezervare în consum efectiv (ex: la shipping)&#10;    /// &lt;/summary&gt;&#10;    public void CommitReservation(Guid reservationId, string reason)&#10;    {&#10;        if (!_reservations.TryGetValue(reservationId, out var reservation))&#10;            throw new ReservationNotFoundException($&quot;Reservation {reservationId} not found&quot;);&#10;        &#10;        // Scadem din stoc și eliminăm rezervarea&#10;        TotalOnHand -= reservation.Quantity;&#10;        _reservations.Remove(reservationId);&#10;        &#10;        EnsureInvariants();&#10;        &#10;        var @event = new StockCommitted(Sku, reservationId, reservation.Quantity, reason, DateTime.UtcNow);&#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: IncreaseStock&#10;    /// Adaugă stoc (ex: recepție marfă)&#10;    /// &lt;/summary&gt;&#10;    public void IncreaseStock(int quantity, string reason)&#10;    {&#10;        if (quantity &lt;= 0)&#10;            throw new InvalidInventoryCommandException(&quot;Quantity must be greater than 0&quot;);&#10;        &#10;        TotalOnHand += quantity;&#10;        &#10;        EnsureInvariants();&#10;        &#10;        var @event = new StockIncreased(Sku, quantity, reason, DateTime.UtcNow);&#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: DecreaseStock&#10;    /// Scade stoc direct (ex: deteriorare, pierdere)&#10;    /// &lt;/summary&gt;&#10;    public void DecreaseStock(int quantity, string reason)&#10;    {&#10;        if (quantity &lt;= 0)&#10;            throw new InvalidInventoryCommandException(&quot;Quantity must be greater than 0&quot;);&#10;        &#10;        if (quantity &gt; TotalOnHand)&#10;            throw new InvalidInventoryCommandException(&#10;                $&quot;Cannot decrease more than on-hand. On-hand: {TotalOnHand}, Requested: {quantity}&quot;);&#10;        &#10;        TotalOnHand -= quantity;&#10;        &#10;        EnsureInvariants();&#10;        &#10;        var @event = new StockDecreased(Sku, quantity, reason, DateTime.UtcNow);&#10;        _uncommittedEvents.Add(@event);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// COMMAND: ExpireReservation&#10;    /// Eliberează automat rezervările expirate&#10;    /// &lt;/summary&gt;&#10;    public void ExpireReservations()&#10;    {&#10;        var now = DateTime.UtcNow;&#10;        var expiredReservations = _reservations.Values&#10;            .Where(r =&gt; r.ExpiresAt &lt;= now)&#10;            .ToList();&#10;        &#10;        foreach (var reservation in expiredReservations)&#10;        {&#10;            Release(reservation.ReservationId, reservation.Quantity, &quot;Reservation expired&quot;);&#10;        }&#10;    }&#10;    &#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    // INVARIANT ENFORCEMENT&#10;    // ═══════════════════════════════════════════════════════════════════════════&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Verifică și asigură că toți invarianții agregatului sunt respectați&#10;    /// &lt;/summary&gt;&#10;    private void EnsureInvariants()&#10;    {&#10;        // INVARIANT 1: TotalOnHand &gt;= 0&#10;        if (TotalOnHand &lt; 0)&#10;            throw new InvariantViolationException(&#10;                $&quot;INVARIANT VIOLATION: TotalOnHand cannot be negative. Current: {TotalOnHand}&quot;);&#10;        &#10;        // INVARIANT 2: Fiecare rezervare are cantitate &gt; 0&#10;        var invalidReservation = _reservations.Values.FirstOrDefault(r =&gt; r.Quantity &lt;= 0);&#10;        if (invalidReservation != null)&#10;            throw new InvariantViolationException(&#10;                $&quot;INVARIANT VIOLATION: Reservation {invalidReservation.ReservationId} has invalid quantity: {invalidReservation.Quantity}&quot;);&#10;        &#10;        // INVARIANT 3: Suma rezervărilor &lt;= TotalOnHand&#10;        var sumReserved = _reservations.Values.Sum(r =&gt; r.Quantity);&#10;        if (sumReserved &gt; TotalOnHand)&#10;            throw new InvariantViolationException(&#10;                $&quot;INVARIANT VIOLATION: Total reserved ({sumReserved}) exceeds on-hand ({TotalOnHand})&quot;);&#10;        &#10;        // INVARIANT 4: Available &gt;= 0&#10;        if (Available &lt; 0)&#10;            throw new InvariantViolationException(&#10;                $&quot;INVARIANT VIOLATION: Available quantity cannot be negative. Current: {Available}&quot;);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Șterge evenimentele necomise (după persistare)&#10;    /// &lt;/summary&gt;&#10;    public void ClearUncommittedEvents()&#10;    {&#10;        _uncommittedEvents.Clear();&#10;    }&#10;}&#10;&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// VALUE OBJECT: Reservation&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;/// &lt;summary&gt;&#10;/// Value Object pentru o rezervare de stoc&#10;/// &lt;/summary&gt;&#10;public class Reservation&#10;{&#10;    public Guid ReservationId { get; }&#10;    public int Quantity { get; set; } // Mutable pentru release parțial&#10;    public string Reason { get; }&#10;    public DateTime ReservedAt { get; }&#10;    public DateTime ExpiresAt { get; }&#10;    &#10;    public bool IsExpired =&gt; DateTime.UtcNow &gt; ExpiresAt;&#10;    &#10;    public Reservation(Guid reservationId, int quantity, string reason, DateTime expiresAt)&#10;    {&#10;        if (quantity &lt;= 0)&#10;            throw new ArgumentException(&quot;Quantity must be greater than 0&quot;, nameof(quantity));&#10;        &#10;        ReservationId = reservationId;&#10;        Quantity = quantity;&#10;        Reason = reason ?? &quot;Unknown&quot;;&#10;        ReservedAt = DateTime.UtcNow;&#10;        ExpiresAt = expiresAt;&#10;    }&#10;}&#10;&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// DOMAIN EXCEPTIONS&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;public class InvalidInventoryCommandException : Exception&#10;{&#10;    public InvalidInventoryCommandException(string message) : base(message) { }&#10;}&#10;&#10;public class InsufficientStockException : Exception&#10;{&#10;    public InsufficientStockException(string message) : base(message) { }&#10;}&#10;&#10;public class ReservationNotFoundException : Exception&#10;{&#10;    public ReservationNotFoundException(string message) : base(message) { }&#10;}&#10;&#10;public class InvariantViolationException : Exception&#10;{&#10;    public InvariantViolationException(string message) : base(message) { }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Proiect/INVENTORY_DDD_DESIGN.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Proiect/INVENTORY_DDD_DESIGN.md" />
              <option name="updatedContent" value="#  BOUNDED CONTEXT: INVENTORY MANAGEMENT - DDD DESIGN&#10;&#10;## Data: November 7, 2025&#10;&#10;---&#10;&#10;## 1. COMENZI → EVENIMENTE (Command-Event Mapping)&#10;&#10;### 1.1 ReserveStock → StockReserved&#10;**Comandă:** `ReserveStock`&#10;- **Input:** SKU, ReservationId, Quantity, Reason, ExpiresAt (optional)&#10;- **Trigger:** Când o comandă este plasată și trebuie rezervat stoc&#10;- **Eveniment emis:** `StockReserved`&#10;- **Scenariu:** Order BC trimite cerere de rezervare → Inventory BC rezervă stocul&#10;&#10;### 1.2 ReleaseStock → StockReleased&#10;**Comandă:** `ReleaseStock`&#10;- **Input:** SKU, ReservationId, Quantity, Reason&#10;- **Trigger:** Când o comandă este anulată, timeout rezervare, sau payment failed&#10;- **Eveniment emis:** `StockReleased`&#10;- **Scenariu:** Order cancelled / Payment failed → eliberează rezervarea&#10;&#10;### 1.3 CommitReservation → StockCommitted&#10;**Comandă:** `CommitReservation`&#10;- **Input:** SKU, ReservationId, Reason&#10;- **Trigger:** Când comanda este expediată (shipping confirmed)&#10;- **Eveniment emis:** `StockCommitted`&#10;- **Scenariu:** Order shipped → transformă rezervarea în consum efectiv&#10;&#10;### 1.4 IncreaseStock → StockIncreased&#10;**Comandă:** `IncreaseStock`&#10;- **Input:** SKU, Quantity, Reason&#10;- **Trigger:** Recepție marfă, ajustare inventar&#10;- **Eveniment emis:** `StockIncreased`&#10;&#10;### 1.5 DecreaseStock → StockDecreased&#10;**Comandă:** `DecreaseStock`&#10;- **Input:** SKU, Quantity, Reason&#10;- **Trigger:** Deteriorare, pierdere, ajustare inventar&#10;- **Eveniment emis:** `StockDecreased`&#10;&#10;---&#10;&#10;## 2. AGREGĂRI (Aggregates)&#10;&#10;### 2.1 AGREGAT ROOT: InventoryItem&#10;&#10;**Identificator:** SKU (String)&#10;&#10;**Responsabilități:**&#10;- Gestionează cantitatea totală de stoc (TotalOnHand)&#10;- Gestionează rezervările active pentru comenzi&#10;- Asigură că suma rezervărilor nu depășește stocul disponibil&#10;- Emite evenimente de domeniu pentru schimbări de stare&#10;&#10;**Structură:**&#10;```csharp&#10;public class InventoryItem&#10;{&#10;    public string Sku { get; private set; }&#10;    public int TotalOnHand { get; private set; }&#10;    public int MinimumStockLevel { get; private set; }&#10;    public int ReorderPoint { get; private set; }&#10;    private Dictionary&lt;Guid, Reservation&gt; _reservations;&#10;    &#10;    // Computed&#10;    public int Available =&gt; TotalOnHand - Sum(Reservations)&#10;}&#10;```&#10;&#10;**Value Objects incluse:**&#10;- `Reservation`: ReservationId, Quantity, Reason, ReservedAt, ExpiresAt&#10;&#10;**Granularitate:**&#10;- Un agregat per SKU (Product)&#10;- Alternativă pentru scalabilitate mare: separare Reservation ca agregat independent&#10;&#10;---&#10;&#10;## 3. REGULI DE VALIDARE&#10;&#10;### 3.1 ReserveStock&#10;&#10;#### Validări pre-condiții:&#10;✅ `Quantity &gt; 0`&#10;✅ `SKU exists` (InventoryItem există în sistem)&#10;✅ `ReservationId is unique` (idempotency - nu există deja)&#10;✅ `Available &gt;= Quantity` (stoc disponibil suficient)&#10;✅ `ExpiresAt &gt; DateTime.UtcNow` (dacă este specificat)&#10;&#10;#### Validări business:&#10;- Nu permite rezervări negative&#10;- Nu permite dublă rezervare cu același ReservationId&#10;- Verifică că nu depășim stocul fizic disponibil&#10;&#10;#### Excepții aruncate:&#10;- `InvalidInventoryCommandException` - parametri invalizi&#10;- `InsufficientStockException` - stoc insuficient&#10;- `InvalidOperationException` - SKU nu există&#10;&#10;---&#10;&#10;### 3.2 ReleaseStock&#10;&#10;#### Validări pre-condiții:&#10;✅ `Quantity &gt; 0`&#10;✅ `ReservationId exists` (rezervarea trebuie să existe)&#10;✅ `Quantity &lt;= ReservedQuantity` (nu elibera mai mult decât e rezervat)&#10;&#10;#### Validări business:&#10;- Permite release parțial (quantity &lt; reserved)&#10;- Permite release total (quantity = reserved) → șterge rezervarea&#10;- Idempotent: dacă rezervarea nu mai există, nu aruncă eroare (opțional)&#10;&#10;#### Excepții aruncate:&#10;- `InvalidInventoryCommandException` - parametri invalizi&#10;- `ReservationNotFoundException` - rezervarea nu există&#10;&#10;---&#10;&#10;### 3.3 CommitReservation&#10;&#10;#### Validări pre-condiții:&#10;✅ `ReservationId exists`&#10;✅ `TotalOnHand &gt;= ReservedQuantity` (pentru a scădea din stoc)&#10;&#10;#### Excepții aruncate:&#10;- `ReservationNotFoundException`&#10;- `InvalidInventoryCommandException`&#10;&#10;---&#10;&#10;### 3.4 IncreaseStock&#10;&#10;#### Validări:&#10;✅ `Quantity &gt; 0`&#10;&#10;---&#10;&#10;### 3.5 DecreaseStock&#10;&#10;#### Validări:&#10;✅ `Quantity &gt; 0`&#10;✅ `TotalOnHand &gt;= Quantity` (nu permite stoc negativ)&#10;&#10;---&#10;&#10;## 4. INVARIANȚI (Invariants)&#10;&#10;### 4.1 Invariant A: Stoc Non-Negativ&#10;```csharp&#10;TotalOnHand &gt;= 0&#10;```&#10;**Descriere:** Stocul fizic nu poate fi niciodată negativ&#10;&#10;**Enforcement:** Verificat în `EnsureInvariants()` și în metodele `DecreaseStock()`, `CommitReservation()`&#10;&#10;**Excepție:** `InvariantViolationException`&#10;&#10;---&#10;&#10;### 4.2 Invariant B: Rezervări Pozitive&#10;```csharp&#10;∀ Reservation r: r.Quantity &gt; 0&#10;```&#10;**Descriere:** Fiecare rezervare trebuie să aibă cantitate strict pozitivă&#10;&#10;**Enforcement:** Verificat la crearea rezervării și după release&#10;&#10;---&#10;&#10;### 4.3 Invariant C: Suma Rezervărilor ≤ Stoc Total&#10;```csharp&#10;Sum(Reservations.Quantity) &lt;= TotalOnHand&#10;```&#10;**Descriere:** Nu poți rezerva mai mult decât ai în stoc fizic (CRUCIAL pentru consistență)&#10;&#10;**Enforcement:** Verificat în `Reserve()` prin `Available &gt;= Quantity`&#10;&#10;**Relaxare:** Dacă se permite backorder, acest invariant se modifică și se gestionează separat&#10;&#10;---&#10;&#10;### 4.4 Invariant D: Disponibil Non-Negativ&#10;```csharp&#10;Available = TotalOnHand - Sum(Reservations) &gt;= 0&#10;```&#10;**Descriere:** Cantitatea disponibilă pentru noi rezervări este întotdeauna &gt;= 0&#10;&#10;**Enforcement:** Derivat automat din Invariant C&#10;&#10;---&#10;&#10;### 4.5 Invariant E: Unicitate ReservationId&#10;```csharp&#10;∀ r1, r2 ∈ Reservations: r1.Id ≠ r2.Id&#10;```&#10;**Descriere:** Fiecare rezervare are un ID unic în cadrul agregatului&#10;&#10;**Enforcement:** Verificat în `Reserve()` prin `_reservations.ContainsKey()`&#10;&#10;---&#10;&#10;## 5. FLUXURI DE PROCES (Process Flows)&#10;&#10;### 5.1 Flux: Plasare Comandă (Happy Path)&#10;```&#10;1. Order BC: PlaceOrder command&#10;2. Order BC: emit OrderPlaced event&#10;3. Inventory BC: receive OrderPlaced (saga/orchestrator)&#10;4. Inventory BC: ReserveStock command&#10;5. Inventory BC: validate (Available &gt;= Quantity)&#10;6. Inventory BC: emit StockReserved event&#10;7. Payment BC: ProcessPayment command&#10;8. Payment BC: emit PaymentSucceeded event&#10;9. Shipping BC: ShipOrder command&#10;10. Inventory BC: CommitReservation command&#10;11. Inventory BC: emit StockCommitted event&#10;```&#10;&#10;### 5.2 Flux: Anulare Comandă&#10;```&#10;1. Order BC: CancelOrder command&#10;2. Order BC: emit OrderCancelled event&#10;3. Inventory BC: receive OrderCancelled&#10;4. Inventory BC: ReleaseStock command&#10;5. Inventory BC: emit StockReleased event&#10;```&#10;&#10;### 5.3 Flux: Payment Failed&#10;```&#10;1. Payment BC: emit PaymentFailed event&#10;2. Inventory BC: receive PaymentFailed (compensation)&#10;3. Inventory BC: ReleaseStock command&#10;4. Inventory BC: emit StockReleased event&#10;5. Order BC: receive compensations → update order status&#10;```&#10;&#10;### 5.4 Flux: Expirare Rezervare (Background Job)&#10;```&#10;1. Scheduler: trigger ExpireReservations job&#10;2. Inventory BC: load all InventoryItems&#10;3. Inventory BC: for each item → ExpireReservations()&#10;4. Inventory BC: emit StockReleased pentru fiecare rezervare expirată&#10;```&#10;&#10;---&#10;&#10;## 6. EXEMPLE DE COD&#10;&#10;### 6.1 Agregat cu Enforcement de Invarianți&#10;&#10;```csharp&#10;public void Reserve(Guid reservationId, int quantity, string reason, DateTime? expiresAt)&#10;{&#10;    // VALIDĂRI&#10;    if (quantity &lt;= 0)&#10;        throw new InvalidInventoryCommandException(&quot;Quantity &gt; 0&quot;);&#10;    &#10;    if (_reservations.ContainsKey(reservationId))&#10;        throw new InvalidInventoryCommandException(&quot;Already reserved (idempotency)&quot;);&#10;    &#10;    if (quantity &gt; Available)&#10;        throw new InsufficientStockException($&quot;Available: {Available}, Requested: {quantity}&quot;);&#10;    &#10;    // OPERAȚIE&#10;    var reservation = new Reservation(reservationId, quantity, reason, expiresAt);&#10;    _reservations.Add(reservationId, reservation);&#10;    &#10;    // VERIFICARE INVARIANȚI&#10;    EnsureInvariants();&#10;    &#10;    // EVENIMENT&#10;    _uncommittedEvents.Add(new StockReserved(...));&#10;}&#10;```&#10;&#10;### 6.2 Verificare Invarianți&#10;&#10;```csharp&#10;private void EnsureInvariants()&#10;{&#10;    // INVARIANT 1: TotalOnHand &gt;= 0&#10;    if (TotalOnHand &lt; 0)&#10;        throw new InvariantViolationException(&quot;TotalOnHand &lt; 0&quot;);&#10;    &#10;    // INVARIANT 2: Rezervări pozitive&#10;    if (_reservations.Values.Any(r =&gt; r.Quantity &lt;= 0))&#10;        throw new InvariantViolationException(&quot;Invalid reservation quantity&quot;);&#10;    &#10;    // INVARIANT 3: Sum(Reservations) &lt;= TotalOnHand&#10;    var sumReserved = _reservations.Values.Sum(r =&gt; r.Quantity);&#10;    if (sumReserved &gt; TotalOnHand)&#10;        throw new InvariantViolationException(&quot;Reserved &gt; OnHand&quot;);&#10;}&#10;```&#10;&#10;---&#10;&#10;## 7. API ENDPOINTS (Quick Reference)&#10;&#10;| Method | Endpoint | Command | Event |&#10;|--------|----------|---------|-------|&#10;| POST | `/api/inventory` | CreateInventoryItem | - |&#10;| GET | `/api/inventory/{sku}` | - | - |&#10;| POST | `/api/inventory/{sku}/reserve` | ReserveStock | StockReserved |&#10;| POST | `/api/inventory/{sku}/release` | ReleaseStock | StockReleased |&#10;| POST | `/api/inventory/{sku}/commit` | CommitReservation | StockCommitted |&#10;| POST | `/api/inventory/{sku}/increase` | IncreaseStock | StockIncreased |&#10;| POST | `/api/inventory/{sku}/decrease` | DecreaseStock | StockDecreased |&#10;&#10;---&#10;&#10;## 8. CONSIDERAȚII TEHNICE&#10;&#10;### 8.1 Concurență&#10;- **Optimistic Concurrency:** Folosește version field pentru EF Core&#10;- **Pessimistic Locking:** Lock la nivel repository (dacă necesar)&#10;- **Retry Policy:** Implementează retry cu exponential backoff pentru conflicte&#10;&#10;### 8.2 Idempotență&#10;- ReservationId asigură idempotență pentru Reserve&#10;- Duplicate commands nu vor genera erori (check `ContainsKey`)&#10;&#10;### 8.3 Event Sourcing (opțional)&#10;- Stocarea evenimentelor `StockReserved`, `StockReleased` în event store&#10;- Reconstituirea agregatului din evenimente&#10;- Avantaje: audit trail complet, replay, debugging&#10;&#10;### 8.4 Scalabilitate&#10;- Pentru volume mari: separare `Reservation` ca agregat distinct&#10;- Sharding per SKU&#10;- Cache pentru queries (read model)&#10;&#10;---&#10;&#10;## 9. TESTE RECOMANDATE&#10;&#10;### Unit Tests&#10;- ✅ Reserve cu stoc suficient → success&#10;- ✅ Reserve cu stoc insuficient → InsufficientStockException&#10;- ✅ Dublă rezervare cu același ID → InvalidInventoryCommandException&#10;- ✅ Release rezervare inexistentă → ReservationNotFoundException&#10;- ✅ Release cantitate mai mare decât rezervat → InvalidInventoryCommandException&#10;- ✅ CommitReservation scade TotalOnHand corect&#10;- ✅ Invarianți menținuți după fiecare operație&#10;&#10;### Integration Tests&#10;- ✅ Flow complet: Reserve → Commit&#10;- ✅ Flow compensare: Reserve → Release&#10;- ✅ Expirare automată rezervări&#10;- ✅ Concurență: 2 rezervări simultane pentru ultimul produs&#10;&#10;---&#10;&#10;## 10. REZUMAT DDD&#10;&#10;### Comenzi identificate:&#10;1. ✅ ReserveStock&#10;2. ✅ ReleaseStock&#10;3. ✅ CommitReservation&#10;4. ✅ IncreaseStock&#10;5. ✅ DecreaseStock&#10;6. ✅ CreateInventoryItem&#10;7. ✅ ExpireReservations&#10;&#10;### Agregate:&#10;1. ✅ **InventoryItem** (Root) - per SKU&#10;&#10;### Value Objects:&#10;1. ✅ **Reservation** - (ReservationId, Quantity, Reason, Dates)&#10;&#10;### Evenimente:&#10;1. ✅ StockReserved&#10;2. ✅ StockReleased&#10;3. ✅ StockCommitted&#10;4. ✅ StockIncreased&#10;5. ✅ StockDecreased&#10;&#10;### Invarianți:&#10;1. ✅ TotalOnHand &gt;= 0&#10;2. ✅ Reservation.Quantity &gt; 0&#10;3. ✅ Sum(Reservations) &lt;= TotalOnHand&#10;4. ✅ Available &gt;= 0&#10;5. ✅ Unique ReservationId per agregat&#10;&#10;---&#10;&#10;**Implementat cu principiile DDD:**&#10;- Ubiquitous Language ✅&#10;- Bounded Context ✅&#10;- Aggregate Root ✅&#10;- Domain Events ✅&#10;- Invariant Enforcement ✅&#10;- Command-Query Separation ✅&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Proiect/Infrastructure/Persistence/InventoryRepository.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Proiect/Infrastructure/Persistence/InventoryRepository.cs" />
              <option name="originalContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - INFRASTRUCTURE LAYER&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Repository pentru persistarea InventoryItem&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;using InventoryManagement.Domain.Inventory;&#10;&#10;namespace InventoryManagement.Infrastructure.Persistence;&#10;&#10;/// &lt;summary&gt;&#10;/// Interface pentru Repository Pattern&#10;/// Abstractizează persistarea agregatului InventoryItem&#10;/// &lt;/summary&gt;&#10;public interface IInventoryRepository&#10;{&#10;    Task&lt;InventoryItem?&gt; GetBySkuAsync(string sku);&#10;    Task&lt;IEnumerable&lt;InventoryItem&gt;&gt; GetAllAsync();&#10;    Task SaveAsync(InventoryItem inventoryItem);&#10;    Task DeleteAsync(string sku);&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Implementare In-Memory pentru Repository&#10;/// Pentru producție, ar trebui implementat cu EF Core sau alt ORM&#10;/// &lt;/summary&gt;&#10;public class InMemoryInventoryRepository : IInventoryRepository&#10;{&#10;    private readonly Dictionary&lt;string, InventoryItem&gt; _store = new();&#10;    private readonly object _lock = new();&#10;    &#10;    public Task&lt;InventoryItem?&gt; GetBySkuAsync(string sku)&#10;    {&#10;        lock (_lock)&#10;        {&#10;            _store.TryGetValue(sku, out var item);&#10;            return Task.FromResult(item);&#10;        }&#10;    }&#10;    &#10;    public Task&lt;IEnumerable&lt;InventoryItem&gt;&gt; GetAllAsync()&#10;    {&#10;        lock (_lock)&#10;        {&#10;            return Task.FromResult(_store.Values.AsEnumerable());&#10;        }&#10;    }&#10;    &#10;    public Task SaveAsync(InventoryItem inventoryItem)&#10;    {&#10;        if (inventoryItem == null)&#10;            throw new ArgumentNullException(nameof(inventoryItem));&#10;        &#10;        lock (_lock)&#10;        {&#10;            _store[inventoryItem.Sku] = inventoryItem;&#10;        }&#10;        &#10;        return Task.CompletedTask;&#10;    }&#10;    &#10;    public Task DeleteAsync(string sku)&#10;    {&#10;        lock (_lock)&#10;        {&#10;            _store.Remove(sku);&#10;        }&#10;        &#10;        return Task.CompletedTask;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="// ═══════════════════════════════════════════════════════════════════════════════&#10;//  BOUNDED CONTEXT: INVENTORY MANAGEMENT - INFRASTRUCTURE LAYER&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// Repository pentru persistarea InventoryItem&#10;// Data: November 7, 2025&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;&#10;using Proiect.Domain.Inventory;&#10;&#10;namespace Proiect.Infrastructure.Persistence;&#10;&#10;/// &lt;summary&gt;&#10;/// Interface pentru Repository Pattern&#10;/// Abstractizează persistarea agregatului InventoryItem&#10;/// &lt;/summary&gt;&#10;public interface IInventoryRepository&#10;{&#10;    Task&lt;InventoryItem?&gt; GetBySkuAsync(string sku);&#10;    Task&lt;IEnumerable&lt;InventoryItem&gt;&gt; GetAllAsync();&#10;    Task SaveAsync(InventoryItem inventoryItem);&#10;    Task DeleteAsync(string sku);&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Implementare In-Memory pentru Repository&#10;/// Pentru producție, ar trebui implementat cu EF Core sau alt ORM&#10;/// &lt;/summary&gt;&#10;public class InMemoryInventoryRepository : IInventoryRepository&#10;{&#10;    private readonly Dictionary&lt;string, InventoryItem&gt; _store = new();&#10;    private readonly object _lock = new();&#10;    &#10;    public Task&lt;InventoryItem?&gt; GetBySkuAsync(string sku)&#10;    {&#10;        lock (_lock)&#10;        {&#10;            _store.TryGetValue(sku, out var item);&#10;            return Task.FromResult(item);&#10;        }&#10;    }&#10;    &#10;    public Task&lt;IEnumerable&lt;InventoryItem&gt;&gt; GetAllAsync()&#10;    {&#10;        lock (_lock)&#10;        {&#10;            return Task.FromResult(_store.Values.AsEnumerable());&#10;        }&#10;    }&#10;    &#10;    public Task SaveAsync(InventoryItem inventoryItem)&#10;    {&#10;        if (inventoryItem == null)&#10;            throw new ArgumentNullException(nameof(inventoryItem));&#10;        &#10;        lock (_lock)&#10;        {&#10;            _store[inventoryItem.Sku] = inventoryItem;&#10;        }&#10;        &#10;        return Task.CompletedTask;&#10;    }&#10;    &#10;    public Task DeleteAsync(string sku)&#10;    {&#10;        lock (_lock)&#10;        {&#10;            _store.Remove(sku);&#10;        }&#10;        &#10;        return Task.CompletedTask;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Proiect/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Proiect/Program.cs" />
              <option name="originalContent" value="using Microsoft.OpenApi.Models;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Add services to the container.&#10;&#10;builder.Services.AddControllers();&#10;// Learn more about configuring OpenAPI at https://aka.ms/aspnet/openapi&#10;builder.Services.AddOpenApi();&#10;&#10;// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle&#10;builder.Services.AddEndpointsApiExplorer();&#10;builder.Services.AddSwaggerGen(c =&gt;&#10;{&#10;    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo { Title = &quot;Proiect PSSC&quot;, Version = &quot;v1&quot; });&#10;});&#10;&#10;&#10;WebApplication app = builder.Build();&#10;&#10;// Configure the HTTP request pipeline.&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.UseSwagger();&#10;    app.UseSwaggerUI();&#10;}&#10;&#10;// Configure the HTTP request pipeline.&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.MapOpenApi();&#10;}&#10;&#10;app.UseHttpsRedirection();&#10;&#10;app.UseAuthorization();&#10;&#10;app.MapControllers();&#10;&#10;app.Run();" />
              <option name="updatedContent" value="using Microsoft.OpenApi.Models;&#10;using Proiect.Infrastructure.Persistence;&#10;using Proiect.Application.Inventory.Handlers;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Add services to the container.&#10;&#10;builder.Services.AddControllers();&#10;// Learn more about configuring OpenAPI at https://aka.ms/aspnet/openapi&#10;builder.Services.AddOpenApi();&#10;&#10;// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle&#10;builder.Services.AddEndpointsApiExplorer();&#10;builder.Services.AddSwaggerGen(c =&gt;&#10;{&#10;    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo { Title = &quot;Proiect PSSC&quot;, Version = &quot;v1&quot; });&#10;});&#10;&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;// INVENTORY BOUNDED CONTEXT - Dependency Injection&#10;// ═══════════════════════════════════════════════════════════════════════════════&#10;builder.Services.AddSingleton&lt;IInventoryRepository, InMemoryInventoryRepository&gt;();&#10;builder.Services.AddScoped&lt;InventoryCommandHandlers&gt;();&#10;&#10;WebApplication app = builder.Build();&#10;&#10;// Configure the HTTP request pipeline.&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.UseSwagger();&#10;    app.UseSwaggerUI();&#10;}&#10;&#10;// Configure the HTTP request pipeline.&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.MapOpenApi();&#10;}&#10;&#10;app.UseHttpsRedirection();&#10;&#10;app.UseAuthorization();&#10;&#10;app.MapControllers();&#10;&#10;app.Run();" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>